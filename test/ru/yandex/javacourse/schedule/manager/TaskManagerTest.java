package ru.yandex.javacourse.schedule.manager;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import ru.yandex.javacourse.schedule.tasks.Epic;
import ru.yandex.javacourse.schedule.tasks.Subtask;
import ru.yandex.javacourse.schedule.tasks.Task;
import ru.yandex.javacourse.schedule.tasks.TaskStatus;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

public abstract class TaskManagerTest<T extends TaskManager> {

    protected T manager;

    protected abstract T createManager();

    @BeforeEach
    public void initManager() {
        manager = createManager();
    }

    @Test
    public void testAddTask() {
        LocalDateTime startTime = LocalDateTime.of(2025, 1, 1, 9, 0);
        Duration duration = Duration.ofMinutes(90);
        Task task = new Task("Test 1", "Testing task 1", TaskStatus.NEW, startTime, duration);
        manager.addNewTask(task);
        assertEquals(1, manager.getTasks().size(), "task should be added");
        Task addedTask = manager.getTasks().getFirst();
        assertEquals(task, addedTask, "added task id should be set");
        Task byIdTask = manager.getTask(task.getId());
        assertEquals(task, byIdTask, "added task id should be found");
    }

    @Test
    public void testAddTaskWithId() {
        Task task = new Task(42, "Test 1", "Testing task 1", TaskStatus.NEW);
        manager.addNewTask(task);
        assertEquals(1, manager.getTasks().size(), "task should be added");
        Task addedTask = manager.getTasks().getFirst();
        assertEquals(task, addedTask, "predefined task id should be set");
    }

    @Test
    public void testAddTaskWithAndWithoutId() {
        Task task0 = new Task("Test 1", "Testing task 1", TaskStatus.NEW);
        Task task1 = new Task(2, "Test 2", "Testing task 2", TaskStatus.NEW);
        manager.addNewTask(task0);
        manager.addNewTask(task1);
        assertEquals(2, manager.getTasks().size(), "both tasks must be stored");
        assertEquals(1, task0.getId(), "autogenerated id should be 1");
        assertEquals(2, task1.getId(), "task predefined id should not change");
    }

    @Test
    void testUpdateGenerator() {
        Task task0 = new Task(10, "Test 1", "Testing task 1", TaskStatus.NEW);
        Task task1 = new Task("Test 2", "Test 2", TaskStatus.NEW);
        manager.addNewTask(task0);
        manager.addNewTask(task1);
        assertEquals(11, task1.getId(), "generator must advance after predefined id");
    }

    @Test
    void testPredefinedIdLessOrEqualGeneratorThrows() {
        Task task0 = new Task(2, "Test 1", "Testing task 1", TaskStatus.NEW);
        manager.addNewTask(task0);
        Task conflict = new Task(1, "Test 2", "Testing task 2", TaskStatus.NEW);
        assertThrows(IllegalArgumentException.class,
                () -> manager.addNewTask(conflict),
                "should throw on id <= generator");
    }

    @Test
    void testPredefinedIdCollisionMapThrows() {
        Task task = new Task(1, "Test 1", "Testing task 1", TaskStatus.NEW);
        manager.addNewTask(task);
        Task conflict = new Task(1, "Test 2", "Testing task 2", TaskStatus.NEW);
        assertThrows(IllegalArgumentException.class,
                () -> manager.addNewTask(conflict),
                "should throw on id collision across maps");
    }

    @Test
    public void testTaskNotChangedAfterAddTask() {
        int id = 1;
        String name = "Test 1";
        String description = "Testing task 1";
        TaskStatus status = TaskStatus.NEW;
        Task taskBefore = new Task(id, name, description, status);
        manager.addNewTask(taskBefore);
        Task taskAfter = manager.getTask(taskBefore.getId());
        assertEquals(id, taskAfter.getId());
        assertEquals(description, taskAfter.getDescription());
        assertEquals(status, taskAfter.getStatus());
        assertEquals(name, taskAfter.getName());
    }

    @Test
    void testDeletedSubtaskRemovesFromEpic() {
        Epic epic = new Epic("Epic 1", "Testing epic 1");
        int epicId = manager.addNewEpic(epic);
        int subtask1 = manager.addNewSubtask(new Subtask("Subtask 1", "Testing subtask 1", TaskStatus.NEW, epicId));
        manager.addNewSubtask(new Subtask("Subtask 2", "Testing subtask 2", TaskStatus.NEW, epicId));
        manager.deleteSubtask(subtask1);
        List<Integer> ids = manager.getEpic(epicId).getSubtaskIds();
        assertFalse(ids.contains(subtask1), "epic must not keep removed subtask id");
    }

    @Test
    void testDeleteEpicRemovesEpicAndAllItsSubtasks() {
        int epic = manager.addNewEpic(new Epic("Epic 1", "Testing epic 1"));
        manager.addNewSubtask(new Subtask("Subtask 1", "Testing subtask 1", TaskStatus.NEW, epic));
        manager.addNewSubtask(new Subtask("Subtask 2", "Testing subtask 2", TaskStatus.NEW, epic));
        manager.deleteEpic(epic);
        assertTrue(manager.getSubtasks().isEmpty(), "subtasks map must be empty after epic removal");
    }

    @Test
    void testTaskBecomesImmutableAfterAdd() {
        Task task = new Task("Task 1", "Testing task 1", TaskStatus.NEW);
        int id = manager.addNewTask(task);
        assertThrows(IllegalStateException.class, () -> task.setName("Task 2"), "name must be immutable after add");
        assertThrows(IllegalStateException.class, () -> task.setDescription("Testing task 2"),
                "description must be immutable after add");
        assertThrows(IllegalStateException.class, () -> task.setStatus(TaskStatus.IN_PROGRESS),
                "status must be immutable after add");
        assertThrows(IllegalStateException.class, () -> task.setId(id + 1),
                "id must be immutable after add");
    }

    @Test
    void testSubtaskBecomesImmutableAfterAdd() {
        int epicId = manager.addNewEpic(new Epic("Epic 1", "Testing epic 1"));
        Subtask subtask = new Subtask("Subtask 1", "Testing subtask 1", TaskStatus.NEW, epicId);
        int subtaskId = manager.addNewSubtask(subtask);
        assertEquals(subtaskId, subtask.getId(), "precondition: id assigned");

        assertThrows(IllegalStateException.class, () -> subtask.setName("Subtask 2"),
                "name must be immutable after add");
        assertThrows(IllegalStateException.class, () -> subtask.setDescription("Testing subtask 2"),
                "description must be immutable after add");
        assertThrows(IllegalStateException.class, () -> subtask.setStatus(TaskStatus.DONE),
                "status must be immutable after add");
        assertThrows(IllegalStateException.class, () -> subtask.setId(subtaskId + 1),
                "id must be immutable after add");
    }

    @Test
    void testEpicBecomesImmutableAfterAdd() {
        Epic epic = new Epic("Epic 1", "Testing epic 1");
        int epicId = manager.addNewEpic(epic);
        assertEquals(epicId, epic.getId(), "precondition: id assigned");

        assertThrows(IllegalStateException.class, () -> epic.setName("Epic 2"),
                "name must be immutable after add");
        assertThrows(IllegalStateException.class, () -> epic.setDescription("Testing epic 2"),
                "description must be immutable after add");
        assertThrows(IllegalStateException.class, () -> epic.setStatus(TaskStatus.IN_PROGRESS),
                "status must be immutable after add");
        assertThrows(IllegalStateException.class, () -> epic.setId(epicId + 1),
                "id must be immutable after add");
    }

    @Test
    void testComputeEpicStatus() {
        int epicNewId = manager.addNewEpic(new Epic("Epic 1", "Testing epic 1"));
        int epicDoneId = manager.addNewEpic(new Epic("Epic 2", "Testing epic 2"));
        int epicNewAndDoneId = manager.addNewEpic(new Epic("Epic 3", "Testing epic 3"));
        int epicInProgressId = manager.addNewEpic(new Epic("Epic 4", "Testing epic 4"));

        Stream.of(
                new Subtask("Subtask 1", "Testing subtask 1", TaskStatus.NEW, epicNewId),
                new Subtask("Subtask 2", "Testing subtask 2", TaskStatus.NEW, epicNewId)
        ).forEach(manager::addNewSubtask);
        Stream.of(
                new Subtask("Subtask 1", "Testing subtask 1", TaskStatus.DONE, epicDoneId),
                new Subtask("Subtask 2", "Testing subtask 2", TaskStatus.DONE, epicDoneId)
        ).forEach(manager::addNewSubtask);
        Stream.of(
                new Subtask("Subtask 1", "Testing subtask 1", TaskStatus.NEW, epicNewAndDoneId),
                new Subtask("Subtask 2", "Testing subtask 2", TaskStatus.DONE, epicNewAndDoneId)
        ).forEach(manager::addNewSubtask);
        Stream.of(
                new Subtask("Subtask 1", "Testing subtask 1", TaskStatus.IN_PROGRESS, epicInProgressId),
                new Subtask("Subtask 2", "Testing subtask 2", TaskStatus.IN_PROGRESS, epicInProgressId)
        ).forEach(manager::addNewSubtask);

        assertEquals(TaskStatus.NEW, manager.getEpic(epicNewId).getStatus(), "status must be NEW");
        assertEquals(TaskStatus.DONE, manager.getEpic(epicDoneId).getStatus(), "status must be DONE");
        assertEquals(TaskStatus.IN_PROGRESS, manager.getEpic(epicNewAndDoneId).getStatus(), "status must be IN_PROGRESS");
        assertEquals(TaskStatus.IN_PROGRESS, manager.getEpic(epicInProgressId).getStatus(), "status must be IN_PROGRESS");
    }

    @Test
    void testSubtaskHasLinkedEpic() {
        Epic epic = new Epic("Epic Linked", "Epic with linked subtasks");
        int epicId = manager.addNewEpic(epic);
        Subtask subtask = new Subtask("Subtask 1", "Linked to epic", TaskStatus.NEW, epicId);
        int subtaskId = manager.addNewSubtask(subtask);

        Subtask loaded = manager.getSubtask(subtaskId);
        assertEquals(epicId, loaded.getEpicId(), "subtask must retain reference to its epic");
        Epic loadedEpic = manager.getEpic(epicId);
        assertTrue(loadedEpic.getSubtaskIds().contains(subtaskId), "epic must list its subtasks");
    }

    @Test
    void testTaskComputeEndTime() {
        LocalDateTime startTime = LocalDateTime.of(2025, 1, 1, 9, 0);
        Duration duration = Duration.ofMinutes(90);
        Task taskWithTime = new Task("Task 1", "Testing task 1", TaskStatus.NEW, startTime, duration);
        Task taskNoStart = new Task("Task 2", "Testing task 2", TaskStatus.NEW);
        int taskIdWithTime = manager.addNewTask(taskWithTime);
        int taskIdNoStart = manager.addNewTask(taskNoStart);

        Task loadedWithTime = manager.getTask(taskIdWithTime);
        Task loadedNoStart = manager.getTask(taskIdNoStart);

        assertEquals(LocalDateTime.parse(startTime.toString()).plusMinutes(duration.toMinutes()), loadedWithTime.getEndTime(),
                "end time must be start + duration");
        assertEquals(Duration.ZERO, taskNoStart.getDuration(), "default duration must be zero");
        assertNull(loadedNoStart.getEndTime(), "end time must be null when start is null");
    }

    @Test
    void testSubtaskComputeEndTime() {
        LocalDateTime startTime = LocalDateTime.of(2025, 1, 2, 14, 0);
        Duration duration = Duration.ofMinutes(120);
        int epicId = manager.addNewEpic(new Epic("Epic 1", "Testing epic 1"));
        Subtask subtaskWithTime = new Subtask("Subtask 1", "Testing subtask 1",
                TaskStatus.NEW, startTime, duration, epicId);
        Subtask subtaskNoStart = new Subtask("Subtask 2", "Testing subtask 2",
                TaskStatus.NEW, epicId);

        Integer idWithTime = manager.addNewSubtask(subtaskWithTime);
        Integer idNoStart = manager.addNewSubtask(subtaskNoStart);
        Subtask loadedWithTime = manager.getSubtask(idWithTime);
        Subtask loadedNoStart = manager.getSubtask(idNoStart);

        assertEquals(startTime.plusMinutes(duration.toMinutes()), loadedWithTime.getEndTime(),
                "end time must be start + duration");
        assertEquals(Duration.ZERO, loadedNoStart.getDuration(), "default duration must be zero");
        assertNull(loadedNoStart.getEndTime(), "end time must be null when start is null");
    }

    @Test
    void testEpicComputeTimes() {
        LocalDateTime startTime = LocalDateTime.of(2025, 1, 3, 9, 30);
        Duration duration = Duration.ofMinutes(45);
        int epicId = manager.addNewEpic(new Epic("Epic 1", "Testing epic 1"));

        Epic epicInitial = manager.getEpic(epicId);
        manager.addNewSubtask(new Subtask("Subtask 1", "Testing subtask 1",
                TaskStatus.NEW, startTime, duration, epicId));
        Epic epicAfter = manager.getEpic(epicId);

        assertNull(epicInitial.getStartTime(), "epic start must be null with no subtasks");
        assertNull(epicInitial.getEndTime(), "epic end must be null with no subtasks");
        assertEquals(Duration.ZERO, epicInitial.getDuration(), "epic duration must be zero with no subtasks");
        assertEquals(startTime, epicAfter.getStartTime(), "epic start must equal earliest subtask start");
        assertEquals(startTime.plusMinutes(duration.toMinutes()), epicAfter.getEndTime(),
                "epic end must equal latest subtask end");
        assertEquals(duration, epicAfter.getDuration(), "epic duration must equal sum of subtask durations");
    }

    @Test
    void testNoTimeOverlapBetweenTasks() {
        LocalDateTime start1 = LocalDateTime.of(2025, 1, 1, 10, 0);
        LocalDateTime start2 = LocalDateTime.of(2025, 1, 1, 10, 30);
        Duration duration = Duration.ofMinutes(60);

        Task task1 = new Task("Task 1", "First", TaskStatus.NEW, start1, duration);
        Task task2 = new Task("Task 2", "Overlap", TaskStatus.NEW, start2, duration);

        manager.addNewTask(task1);
        assertThrows(IllegalArgumentException.class,
                () -> manager.addNewTask(task2),
                "second task overlaps first â€” must throw or reject");
    }

    @Test
    void testGetPrioritizedTasksOrder() {
        LocalDateTime t1 = LocalDateTime.of(2025, 1, 1, 9, 0);
        LocalDateTime t2 = LocalDateTime.of(2025, 1, 1, 11, 0);
        LocalDateTime t3 = LocalDateTime.of(2025, 1, 1, 15, 0);
        Duration d1 = Duration.ofMinutes(60);
        Duration d2 = Duration.ofMinutes(30);
        Duration d3 = Duration.ofMinutes(90);
        Task task = new Task("Task 1", "Testing order", TaskStatus.NEW, t2, d2);
        int epicId = manager.addNewEpic(new Epic("Epic 1", "For subtasks"));
        Subtask subtask = new Subtask("Subtask 1", "Early subtask", TaskStatus.NEW, t1, d1, epicId);
        Task lateTask = new Task("Task 2", "Later task", TaskStatus.NEW, t3, d3);
        Task noTimeTask = new Task("Task 3", "No time set", TaskStatus.NEW);

        manager.addNewTask(task);
        manager.addNewSubtask(subtask);
        manager.addNewTask(lateTask);
        manager.addNewTask(noTimeTask);
        List<Task> prioritized = manager.getPrioritizedTasks().stream().toList();

        assertEquals(3, prioritized.size(), "prioritized list must exclude tasks without startTime");
        assertFalse(prioritized.contains(noTimeTask), "tasks without startTime must not appear in prioritized list");
        assertEquals(subtask, prioritized.get(0), "earliest start task must come first");
        assertEquals(task, prioritized.get(1), "middle start task must come second");
        assertEquals(lateTask, prioritized.get(2), "latest start task must come last");
    }
}
